<!DOCTYPE html>
<html>
<head>
  <title>Javascript Tetris</title>
  <style>
    body      { font-family: Helvetica, sans-serif; }
    #tetris   { margin: 1em auto; padding: 1em; border: 4px solid black; border-radius: 10px; background-color: #F8F8F8; }
    #stats    { display: inline-block; vertical-align: top; }
    #canvas   { display: inline-block; vertical-align: top; box-shadow: 10px 10px 10px #999; border: 2px solid #333; }
    #menu     { display: inline-block; vertical-align: top; position: relative; }
    #menu p   { margin: 0.5em 0; text-align: center; }
    #menu p a { text-decoration: none; color: black; }
    #upcoming { display: block; margin: 0 auto; background-color: #E0E0E0; }
    #score    { color: red; font-weight: bold; vertical-align: middle; }
    #rows     { color: blue; font-weight: bold; vertical-align: middle; }
    #stats    { position: absolute; bottom: 0em; right: 1em; }
    @media screen and (min-width:   0px) and (min-height:   0px)  { #tetris { font-size: 0.75em; width: 250px; } #menu { width: 100px; height: 200px; } #upcoming { width:  50px; height:  50px; } #canvas { width: 100px; height: 200px; } } /* 10px chunks */
    @media screen and (min-width: 400px) and (min-height: 400px)  { #tetris { font-size: 1.00em; width: 350px; } #menu { width: 150px; height: 300px; } #upcoming { width:  75px; height:  75px; } #canvas { width: 150px; height: 300px; } } /* 15px chunks */
    @media screen and (min-width: 500px) and (min-height: 500px)  { #tetris { font-size: 1.25em; width: 450px; } #menu { width: 200px; height: 400px; } #upcoming { width: 100px; height: 100px; } #canvas { width: 200px; height: 400px; } } /* 20px chunks */
    @media screen and (min-width: 600px) and (min-height: 600px)  { #tetris { font-size: 1.50em; width: 550px; } #menu { width: 250px; height: 500px; } #upcoming { width: 125px; height: 125px; } #canvas { width: 250px; height: 500px; } } /* 25px chunks */
    @media screen and (min-width: 700px) and (min-height: 700px)  { #tetris { font-size: 1.75em; width: 650px; } #menu { width: 300px; height: 600px; } #upcoming { width: 150px; height: 150px; } #canvas { width: 300px; height: 600px; } } /* 30px chunks */
    @media screen and (min-width: 800px) and (min-height: 800px)  { #tetris { font-size: 2.00em; width: 750px; } #menu { width: 350px; height: 700px; } #upcoming { width: 175px; height: 175px; } #canvas { width: 350px; height: 700px; } } /* 35px chunks */
    @media screen and (min-width: 900px) and (min-height: 900px)  { #tetris { font-size: 2.25em; width: 850px; } #menu { width: 400px; height: 800px; } #upcoming { width: 200px; height: 200px; } #canvas { width: 400px; height: 800px; } } /* 40px chunks */
  </style>
</head>

<div id="tetris">
    <div id="menu">
      <p id="start"><a href="javascript:play();">Press Space to Play.</a></p>
      <p><canvas id="upcoming"></canvas></p>
      <p>score <span id="score">00000</span></p>
      <p>rows <span id="rows">0</span></p>
    </div>
    <canvas id="canvas">
      Sorry, this example cannot be run because your browser does not support the &lt;canvas&gt; element
    </canvas>
</div>

<body>
<script>
var KEY = { ESC: 27, SPACE: 32, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40};
var DIR = { UP: 0, RIGHT: 1, DOWN: 2, LEFT: 3, MIN: 0, MAX: 3 };
var actions;

// Render
var canvas = document.getElementById('canvas');
var ctx = canvas.getContext('2d');
var ucanvas = document.getElementById('ucanvas');
var uctx = canvas.getContext('2d');

if (!window.requestAnimationFrame) { // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
      window.requestAnimationFrame = window.webkitRequestAnimationFrame ||
                                     window.mozRequestAnimationFrame    ||
                                     window.oRequestAnimationFrame      ||
                                     window.msRequestAnimationFrame     ||
                                     function(callback, element) {
                                       window.setTimeout(callback, 1000 / 60);
                                     }
}

window.onload = function() {
    //var mycanv = document.getElementById("canvas1");
    //var ctx = mycanv.getContext("2d");

// change for git2
//testing

	var map_x = 16;
	var map_y = 24;
	var piece_types = 7;
    var score = 0;
	var playing = false;
	var total_time;
	var speed = 0.6;
	
	var current_piece;
	
	var img_A = new Image();
	var img_T = new Image();
	var img_G = new Image();
	var img_C = new Image();
	
	function initialise_images(){
		img_A.src = "images/A8.png";
		img_T.src = "images/T8.png";
		img_G.src = "images/G8.png";
		img_C.src = "images/C8.png";
	}
	
	var letter_array = new Array("A","T","G","C");

	//map[]=0 -> unoccupied ; map[]=1 -> occupied by A ; map[]=2 -> occupied by T ; map[]=3 -> occupied by G ; map[]=4 -> occupied by C
	var map = new Array(map_x);

	function initiate_map(){
		for (var i = 0; i < map_y; i++) {
			map[i] = [];
			for(var j = 0; j < map_x; j++){
				map[i][j] = 0;
			}
		}
	}
	
    function run() {

	initiate_map();
    //showStats(); // initialize FPS counter
    //addEvents(); // attach keydown and resize events
    document.addEventListener('keydown', keydown, false);
    //window.addEventListener('resize', resize, false);
	total_time = 0;
    var last = now = new Date().getTime();
    function frame() {
        now = new Date().getTime();
        update(Math.min(1, (now - last) / 1000.0)); // using requestAnimationFrame have to be able to handle large delta's caused when it 'hibernates' in a background or non-visible tab
        draw();
        last = now;
        requestAnimationFrame(frame, canvas);
    }
/*
    resize(); // setup all our sizing information
    reset();  // reset the per-game variables
*/
    frame();  // start the first frame
    }

	function occupied(x,y){
		if(map[x][y - 1 ] == 0){
			return false;
		}
		else{
			return true; 
		}
	}
	
	var pieces_array = [];
	
	function populate_pieces_array(){
	}
//i.rotations.length
	var piece_i = { size: 2, color: 'cyan', current_rotation: 0,
	rotations: {rotation1: [[1,1,1,1], 
							[0,0,0,0],
							[0,0,0,0],
							[0,0,0,0]],
				rotation2: [[0,0,1,0], 
							[0,0,1,0],
							[0,0,1,0],
							[0,0,1,0]] }  };
	var piece_j = { size: 2, 	color: 'yellow',current_rotation: 0,
	rotations:	{rotation1: [[0,1,1,0], 
							[1,1,0,0],
							[0,0,0,0],
							[0,0,0,0]],
				rotation2: [[1,0,0,0], 
							[1,1,0,0],
							[0,1,0,0],
							[0,0,0,0]] }  };
    var piece_l = { size: 2, color: 'blue',current_rotation: 0,
	rotations:	{rotation1: [[1,1,0,0], 
							[0,1,1,0],
							[0,0,0,0],
							[0,0,0,0]],
				rotation2: [[0,0,1,0], 
							[0,1,1,0],
							[0,1,0,0],
							[0,0,0,0]] }  };
    var piece_o = { size: 1, color: 'red',current_rotation: 0,
	rotations:	{rotation1: [[0,1,1,0], 
							[0,1,1,0],
							[0,0,0,0],
							[0,0,0,0]]}  };
    var piece_s = { size: 4, 	color: 'green',current_rotation: 0,
	rotations:	{rotation1: [[1,0,0,0], 
							[1,0,0,0],
							[1,1,0,0],
							[0,0,0,0]],
				rotation2: [[0,0,1,0], 
							[1,1,1,0],
							[0,0,0,0],
							[0,0,0,0]], 
				rotation3: [[1,1,0,0], 
							[0,1,0,0],
							[0,1,0,0],
							[0,0,0,0]],
				rotation4: [[1,1,1,0], 
							[1,0,0,0],
							[0,0,0,0],
							[0,0,0,0]]}  };
    var piece_t = { size: 4, color: 'purple',current_rotation: 0,
	rotations:	{rotation1: [[0,1,0,0], 
							[0,1,0,0],
							[1,1,0,0],
							[0,0,0,0]],
				rotation2: [[1,0,0,0], 
							[1,1,1,0],
							[0,0,0,0],
							[0,0,0,0]], 
				rotation3: [[1,1,0,0], 
							[1,0,0,0],
							[1,0,0,0],
							[0,0,0,0]],
				rotation4: [[1,1,1,0], 
							[0,0,1,0],
							[0,0,0,0],
							[0,0,0,0]]}  };
    var piece_z = { size: 4, color: 'orange', current_rotation: 0,
	rotations:	{rotation1: [[0,1,0,0], 
							[1,1,1,0],
							[0,0,0,0],
							[0,0,0,0]],
				rotation2: [[0,1,0,0], 
							[1,1,0,0],
							[0,1,0,0],
							[0,0,0,0]], 
				rotation3: [[1,1,1,0], 
							[0,1,0,0],
							[0,0,0,0],
							[0,0,0,0]],
				rotation4: [[0,1,0,0], 
							[0,1,1,0],
							[0,1,0,0],
							[0,0,0,0]]}  };

	function create_random_piece(piece_type){
		switch(piece_type){
			case 1:
			return piece_i;
				break;
			case 2:
			return piece_j;
				break;
			case 3:
			return piece_l;		
				break;
			case 4:
			return piece_o;
				break;
			case 5:
			return piece_s;
				break;
			case 6:
			return piece_t;
				break;
			case 7:
			return piece_z;
				break;
		}
	}
	function play() {
		//reset();
		playing = true;
		current_piece = spawn_piece();
		//game_loop();
		//update(Math.min(1, (now - last) / 1000.0)); 
	}

	function spawn_piece(){
		
		var pieceRandomizer = Math.floor((Math.random() * piece_types) + 1);
		//var piece = create_random_piece(pieceRandomizer);
		var piece = piece_z;
		//Stim ce pozitie e ocupata
			//piesa este in rotation1
		var map_middle = map_x / 2;
		var map_top = 0;
		var temp = piece.rotations.rotation1;
		var piece_x = 0;
		var piece_y;
		for (var i = map_top; i < map_top + 4; i++){
			piece_y = 0;
			for (var j = map_middle -2; j < map_middle + 2; j++){
				//map[i][j] = piece;
				//if(map[i][j] === 1){
				//	drawBlock(j,i,piece.color);
				//}
				//draft
				if (temp[piece_x][piece_y] === 1) {
					map[i][j] = piece; 
				}
				//
				piece_y++;
			}
			piece_x++;
		}
		//tempDrawBlock(map_middle - 3, 0, 'cyan');
		//Render pe ecran piesele

		piece.location = {};
		piece.location.x = map_top;
		piece.location.y = map_middle - 2;
		return piece;
	}

	function drop() {
		// stergem vechea pozitie
		var temp = current_piece.rotations.rotation1;

		var piece_x = 0;
		var piece_y;
		for (var i = current_piece.location.x; i < current_piece.location.x + 4; i++){
			piece_y = 0;
			for (var j = current_piece.location.y; j < current_piece.location.y + 4; j++){
				if (piece_x - 4 < map_x && map[i]) {
					map[i][j] = 0;
				}
				//drawBlockNoBorder(j,i,'white');
				piece_y++;
			}
			piece_x++;
			// if (i - 3> map_x) {
			// 	break;
			// }
		}
		piece_x = 0;
		//ctx.strokeRect(0, 0, map_x*dx - 1, map_y*dy - 1);

		current_piece.location.x++;

		for (var i = current_piece.location.x; i < current_piece.location.x + 4; i++){
			piece_y = 0;
			for (var j = current_piece.location.y; j < current_piece.location.y + 4; j++){
				//map[i][j] = temp[piece_x][piece_y];
				//if(map[i][j] === 1){
				//	drawBlock(j,i, current_piece.color);
				//}
				if (temp[piece_x][piece_y] === 1 && piece_x - 4 < map_x) {
					map[i][j] = current_piece; 
				}
				piece_y++;
			}
			piece_x++;
			// if (i - 4> map_x) {
			// 	break;
			// }
		}
	}

	function check_bottom(){
		console.log(current_piece.location.x);
		console.log(map_y - 3);
		for (var i = 0; i < map_x - 1; i++) {
			if (map[map_y-1][i] && current_piece.location.x == map_y - 2 ) {
				return true;
			}
		}
		
	/*	var piece_x = 0;
		var piece_y;
		for (var i = current_piece.location.x; i < current_piece.location.x + 4; i++){
			piece_y = 0;
			for (var j = current_piece.location.y; j < current_piece.location.y + 4; j++){
				if(current_piece.rotations.rotation1[piece_x][piece_y] === 1){
					if (map[current_piece.location.x + 1][current_piece.location.y] && current_piece.) {
						return true;
					}
				}
				piece_y++;
			}
			piece_x++;
		}*/
		return false;
	}

	function check_collision(){

	}

	function rotate_piece(piece){
		
	}
	
	function search_removable_blocks(){
		var ia = -1,
			ja,
			ib,
			jb;
		for (var i = 0; i < map_x; i++) {
			for(var j = 0; j < map_y; j++){
				if(map[i][j] > 0 && (map[i - 1][j] > 0)){
					ia = i;
					ja = j;
					ib = i - 1;
					jb = j;
				}
				if(map[i][j] > 0 && (map[i + 1][j] > 0)){
					ia = i;
					ja = j;
					ib = i + 1;
					jb = j;
				}
				if(map[i][j] > 0 && (map[i][j - 1] > 0)){
					ia = i;
					ja = j;
					ib = i;
					jb = j - 1;
				}
				if(map[i][j] > 0 && (map[i][j + 1] > 0)){
					ia = i;
					ja = j;
					ib = i;
					jb = j + 1;
				}
				remove_blocks(ia,jb,ib,jb);
			}
		}
		if(ia != -1){
			search_removable_blocks();
			}
	}
	
	function remove_blocks(ia,jb,ib,jb){
		map[ia][ja] = 0;
		map[ib][jb] = 0;
	}
	
	function increase_score(){
	}

	function game_loop() {
		if (playing) {
            if (speed > 0.1) {
                speed = speed - 0.005;
            }
            //setTimeout(game_loop, (speed));
        }
	}

	function update(timer){
		if (playing) {
        //if (vscore < score)
        //  setVisualScore(vscore + 1);
        //handle(actions.shift());
        total_time = total_time + timer;
        if (total_time > speed) {
          total_time = total_time - speed;
		  if(check_bottom() == false){
			drop();
			}
			else{
				current_piece = spawn_piece();
				console.log(map);
			}
        }
      }
	}
		/*
	function draw_block() {
			
	}
		
	function draw_shape() {
			
	}
		
	function draw_background() {
			
	}
		
	function move_left() {
			current_piece = 
	}
		
	function move_right(){
			
	}
	function change_position(){
			
	}
	*/
	function move_down(){
			
	}	
	function draw() {
        ctx.save();
        ctx.lineWidth = 1;
        ctx.translate(0.5, 0.5); // for crisp 1px black lines
        drawMap();
        //drawNext();
        //drawScore();
        //drawRows();
        ctx.restore();
    }
        // Temp
        var dx = canvas.width  / map_x; // pixel size of a single tetris block
        var dy = canvas.height / map_y; // (ditto)
        //Temp
    function drawMap() {
      //if (invalid.court) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (playing)
          //drawPiece(ctx, current.type, current.x, current.y, current.dir);
        var x, y, block;
        for(y = 0; y < map_y; y++) {
          for (x = 0; x < map_x; x++) {
            //if (block = getBlock(x,y))
            //drawBlockNoBorder(x, y, 'white');
			  //drawBlock(ctx, x, y, block.color);
			  
			  //draft
			if (map[y][x] === 0) {
				drawBlockNoBorder(x, y, 'white');
			}
			else {
				drawBlock(x, y, 'cyan');
			}
			  //
          }
        }
        ctx.strokeRect(0, 0, map_x*dx - 1, map_y*dy - 1); // court boundary
        //invalid.court = false;
      //}
    }

    function drawBlock(x, y, color) {
		ctx.fillStyle = color;
		ctx.fillRect(x*dx, y*dy, dx, dy);
		ctx.strokeRect(x*dx, y*dy, dx, dy);
	}

	function drawBlockNoBorder(x, y, color) {
		ctx.fillStyle = color;
		ctx.fillRect(x*dx, y*dy, dx, dy);
    }
	
	function keydown(ev) {
      var handled = false;
      if (playing) {
        switch(ev.keyCode) {
		  case KEY.LEFT:
			actions.push(DIR.LEFT);
			handled = true;
			break;
		  case KEY.RIGHT:
			actions.push(DIR.RIGHT);
			handled = true;
			break;
		  case KEY.UP:
			actions.push(DIR.UP);
			handled = true;
			break;
		  case KEY.DOWN:
			actions.push(DIR.DOWN);
			handled = true;
			break;
		  case KEY.ESC:
			lose();
			handled = true;
			break;
        }
      }
      else if (ev.keyCode == KEY.SPACE) {
        play();
        handled = true;
      }
      if (handled)
        ev.preventDefault(); // prevent arrow keys from scrolling the page (supported in IE9+ and all other browsers)
    }

    run();
}
</script>